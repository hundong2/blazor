@using JsonPuzzleEditor.SharedComponents.Models

<div class="json-node" style="margin-left: @(Depth * 20)px;">
    @if (ParentNode != null && ParentNode.NodeType == JsonNodeType.Object) // Only show key input if parent is an object
    {
        <input type="text" @bind="Node.Key" @oninput="NotifyChanged" placeholder="key" class="node-key-input" />
        <span class="node-key-separator">:</span>
    }

    @* Value display and editing based on NodeType *@
    @switch (Node.NodeType)
    {
        case JsonNodeType.Object:
            <span class="node-object-marker">{"{"}</span>
            @foreach (var child in Node.Children.ToList()) // Use ToList() for safe iteration if collection is modified
            {
                <NodeDisplay Node="child" Depth="Depth + 1" OnChanged="OnChanged" ParentNode="Node" OnDeleteRequested="HandleChildDeleteRequested" />
            }
            <div style="margin-left: @((Depth + 1) * 20)px;">
                <button @onclick="() => AddChildNode(Node, JsonNodeType.String)" class="add-button">Add Property</button>
            </div>
            <span class="node-object-marker" style="margin-left: @(Depth * 20)px;">{"}"}</span>
            break;

        case JsonNodeType.Array:
            <span class="node-array-marker">{"["}</span>
            @foreach (var child in Node.Children.ToList())
            {
                <NodeDisplay Node="child" Depth="Depth + 1" OnChanged="OnChanged" ParentNode="Node" OnDeleteRequested="HandleChildDeleteRequested" />
            }
            <div style="margin-left: @((Depth + 1) * 20)px;">
                <button @onclick="() => AddChildNode(Node, JsonNodeType.String, true)" class="add-button">Add Item</button>
            </div>
            <span class="node-array-marker" style="margin-left: @(Depth * 20)px;">{"]"}</span>
            break;

        case JsonNodeType.String:
            <input type="text" @bind="Node.StringValue" @oninput="NotifyChanged" class="node-value-string" />
            break;

        case JsonNodeType.Number:
            <input type="number" @bind="Node.NumberValue" @oninput="NotifyChanged" class="node-value-number" />
            break;

        case JsonNodeType.Boolean:
            <select @bind="Node.BooleanValue" @onchange="NotifyChanged" class="node-value-boolean">
                <option value="true">true</option>
                <option value="false">false</option>
            </select>
            break;

        case JsonNodeType.Null:
            <span class="node-value-null">null</span>
            break;
    }

    @* Type Selector and Delete Button for all nodes except the root object/array's direct value part (if it were a single value) *@
    <select @onchange="(e) => ChangeNodeType(e.Value?.ToString())" class="node-type-selector" disabled="@(ParentNode == null && (Node.NodeType == JsonNodeType.Object || Node.NodeType == JsonNodeType.Array))">
        <option value="@JsonNodeType.String" selected="@(Node.NodeType == JsonNodeType.String)">String</option>
        <option value="@JsonNodeType.Number" selected="@(Node.NodeType == JsonNodeType.Number)">Number</option>
        <option value="@JsonNodeType.Boolean" selected="@(Node.NodeType == JsonNodeType.Boolean)">Boolean</option>
        <option value="@JsonNodeType.Null" selected="@(Node.NodeType == JsonNodeType.Null)">Null</option>
        <option value="@JsonNodeType.Object" selected="@(Node.NodeType == JsonNodeType.Object)">Object</option>
        <option value="@JsonNodeType.Array" selected="@(Node.NodeType == JsonNodeType.Array)">Array</option>
    </select>

    @if (ParentNode != null) // Root node cannot be deleted this way
    {
        <button class="delete-node-button" @onclick="RequestDeleteSelf">X</button>
    }
</div>

@code {
    [Parameter]
    public JsonNodeData Node { get; set; } = null!;

    [Parameter]
    public JsonNodeData? ParentNode { get; set; } // To determine if key is needed or if it's an array item

    [Parameter]
    public int Depth { get; set; }

    [Parameter]
    public EventCallback OnChanged { get; set; }

    [Parameter]
    public EventCallback<JsonNodeData> OnDeleteRequested { get; set; }


    private void NotifyChanged()
    {
        OnChanged.InvokeAsync();
    }

    private void AddChildNode(JsonNodeData parentNode, JsonNodeType type, bool isArrayItem = false)
    {
        var newNode = new JsonNodeData
        {
            NodeType = type,
            Key = parentNode.NodeType == JsonNodeType.Object && !isArrayItem ? $"newKey{parentNode.Children.Count + 1}" : null
        };

        switch (type)
        {
            case JsonNodeType.String: newNode.Value = ""; break;
            case JsonNodeType.Number: newNode.Value = 0; break;
            case JsonNodeType.Boolean: newNode.Value = false; break;
            case JsonNodeType.Null: newNode.Value = null; break;
            case JsonNodeType.Object: newNode.Children = new List<JsonNodeData>(); break;
            case JsonNodeType.Array: newNode.Children = new List<JsonNodeData>(); break;
        }
        parentNode.Children.Add(newNode);
        NotifyChanged();
    }

    private void ChangeNodeType(string? typeString)
    {
        if (string.IsNullOrEmpty(typeString) || !Enum.TryParse<JsonNodeType>(typeString, out var newType))
        {
            return;
        }

        Node.NodeType = newType;
        if (newType == JsonNodeType.Object || newType == JsonNodeType.Array)
        {
            Node.Value = null;
            Node.Children ??= new List<JsonNodeData>(); // Initialize if null, keep if exists
        }
        else
        {
            Node.Children.Clear(); // Clear children if not object or array
            switch (newType)
            {
                case JsonNodeType.String: Node.Value = Node.Value?.ToString() ?? ""; break;
                case JsonNodeType.Number:
                    if (double.TryParse(Node.Value?.ToString(), out double numValue)) Node.Value = numValue;
                    else Node.Value = 0;
                    break;
                case JsonNodeType.Boolean:
                    if (bool.TryParse(Node.Value?.ToString(), out bool boolValue)) Node.Value = boolValue;
                    else Node.Value = false;
                    break;
                case JsonNodeType.Null: Node.Value = null; break;
            }
        }
        NotifyChanged();
    }

    private void RequestDeleteSelf()
    {
        OnDeleteRequested.InvokeAsync(Node);
    }

    private void HandleChildDeleteRequested(JsonNodeData childNode)
    {
        // This node is the parent of the node to be deleted.
        // This is a more direct way to handle deletion for children.
        if (Node.Children.Remove(childNode))
        {
            NotifyChanged();
        }
        // If the child wasn't directly in this node's children (which shouldn't happen with this event)
        // or if further bubbling up is needed, the top-level JsonEditor's HandleDeleteNode would still be the ultimate fallback.
    }
}
